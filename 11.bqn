#!/usr/bin/env bqn

uâ†	â€¢Import"U"

#Sâ†	{ğ•©ğ•¨.SetÂ¨1+âŠ’ğ•©}
#Dâ†	âŠ¢â€¢HashMapâŠ’+1Ë™
Fâ†	{0â‰¡ğ•©?1;
	0â‰¡2|â‰ sâ†â€¢Reprğ•©?
	u.PinÂ¨(â‰ Ã·2Ë™)âŠ¸(â†‘â‹ˆâ†“)s;
	2024Ã—ğ•©}

iâ†	' 'u.StnâŠ‘â€¢FLinesâŠ‘â€¢args
#câ†	â€¢HashMapËœ""

#NaÃ¯ve solution. Obviously incredibly sluggish.
â€¢Show	â‰ (âˆ¾FÂ¨)âŸ25 i

#Barely faster, definitely not worth the effort
#â€¢Show	{â‰ (âˆ¾(c.Hasâ—¶âŸ¨(âŠ¢âŠ£c.Set)âŸœF,c.GetâŸ©)Â¨)âŸ25ğ•©}i

#Double HashMap version stub; needs refactoring
#I dislike the "global variables", but they are
#quite useful for repeats, especially since the
#final tally will be stored in the histogram h.
#hâ†	D i
#{râ†Dâˆ¾(c.Hasâ—¶âŸ¨c.GetâŠ£c.SetâŸœF,c.GetâŸ©)Â¨ğ•©
#	h.SetâŸœ(h.Hasâ—¶âŸ¨r.Get,h.GetÃ—r.GetâŸ©)Â¨r.Keys@
#	}âŸ25 h.Keys@
#In theory this operated only on unique values.
#Apparently this was a dead-end. Using â€¢HashMap
#had negligible performance optimization as the
#time complexity stayed approximately at O(bâ¿).
