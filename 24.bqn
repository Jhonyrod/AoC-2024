#!/usr/bin/env bqn

uâ†	â€¢Import"U"

#List of pairs to HashMap, might add to Utils
Hâ†	â€¢HashMapËÂ·â‰>

# Instruction parser
Fâ†{	wâ€¿yâ€¿x:	sâ†"AND"â€¿"OR"â€¿"XOR"
			mâ†"Invalid operator: "
			#Select operator based on the string
			#Throw error on unknown instruction.
			Iâ†(sâŠ¸âŠâŒ¾<y)â—¶âˆ§â€¿âˆ¨â€¿â‰ â€¿(!mâˆ¾â€¢ReprâŸœy)
#Recursive stub	#Lâ†â€¢Typeâ—¶(z.Hasâ—¶âŠ¢â€¿z.Get)â€¿âŠ¢
			#NOP on non binary w and x
			w(âˆ§Â´â‹ˆâˆŠâ†•âˆ˜2)â—¶âŸ¨ğ•©,IâŸ©x;
	ğ•©:		!"Invalid length: 3â‰¢â‰ ğ•©"}

iâ€¿câ†u.Snlâ€¢FLinesâŠ‘â€¢args

#Initial values dictionary
dâ†	H i((âŠ‘"1"âˆŠâŠ¢)âŒ¾(Â¯1âŠ¸âŠ‘)':'âŠ¸u.Spl)Â¨â†©
#Interconnections intermediate parser
c	(' 'âŠ¸u.SplâŒ¾âŠ‘" -> "u.SowâŠ¢)Â¨â†©
zâ†	""
{ğ•Šr:
	#Replace "wire" names with their values.
	#Concurrently try to operate on results.
	c(F d.Hasâ—¶âŠ¢â€¿d.GetÂ¨)âŒ¾âŠ‘Â¨â†©
	#Group by depth.
	câ€¿râ†©2â†‘(âŒ½â‰¡Â¨âŠ”âŠ¢)c
	#Replace the HM with the resolved values
	#Concurrently, if a zxx node is found to
	#be completely resolved, append it to z.
	zâˆ¾â†©(('z'=âŠ‘âˆ˜âˆ¾Â¨)/âŠ¢)râŒ½Â¨â†©
	dâ†©HâŠ@r
	r
}â€¢_while_(0<â‰ )i
#Lexicographically sort keys according to LSB
#and convert the list of binary digits to num
#I had to bodge c in as it ended containing a
#single resolved zxx node. This might make it
#a specialized solution for my puzzle inputs.
â€¢Show u.B2nâŠ¢Â´Â¨âˆ¨zâˆ¾âŒ½Â¨c
